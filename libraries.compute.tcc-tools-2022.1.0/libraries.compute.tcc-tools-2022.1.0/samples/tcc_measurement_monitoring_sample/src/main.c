/*******************************************************************************
Copyright Intel Corporation.
This software and the related documents are Intel copyrighted materials, and your use of them
is governed by the express license under which they were provided to you (License).
Unless the License provides otherwise, you may not use, modify, copy, publish, distribute, disclose
or transmit this software or the related documents without Intel's prior written permission.
This software and the related documents are provided as is, with no express or implied warranties,
other than those that are expressly stated in the License.

*******************************************************************************/

/*
 * This sample is a self-contained example of a monitoring application. The sample monitors
 * measurements generated by tcc_single_measurement_sample. To see how it works, run the sample concurrently with
 * tcc_single_measurement_sample. As tcc_single_measurement_sample runs, tcc_measurement_monitoring_sample prints the
 * latency
 * of each workload iteration. The sample also prints a message when a measurement exceeds the deadline.
 */


#include <getopt.h>
#include <unistd.h>

#include "args_parse.h"
#include "macros.h"
#include "tcc/err_code.h"
#include "tcc/measurement_helpers.h"


int main(int argc, char** argv)
{
    int tcc_status = parse_args(argc, argv, NULL);
    if (tcc_status == TCC_PARSE_ERROR) {
        print_usage();
        return -TCC_E_BAD_PARAM;
    }
    if (tcc_status == TCC_PRINT_HELP) {
        print_usage();
        return TCC_E_SUCCESS;
    }

    uint64_t value;
    struct tcc_measurement_buffer* buffer = NULL;
    unsigned counter = 0;
    unsigned deadline_counter = 0;
    static const char measurement_name[] = "Approximation";

    /* Extract the buffer size from the environment variable.*/
    uint64_t buffer_size = tcc_measurement_get_buffer_size_from_env(measurement_name);
    if (buffer_size == 0) {
        print_usage();
        return -TCC_E_BAD_PARAM;
    }
    printf("Initializing monitoring for \"%s\", buffer size %lu\n", measurement_name, buffer_size);

    /* Extract the deadline settings from the environment variable */
    TCC_TIME_UNIT time_unit = tcc_measurement_get_time_unit_from_env();
    uint64_t deadline_raw = tcc_measurement_get_deadline_from_env(measurement_name);
    uint64_t deadline = tcc_measurement_convert_time_units_to_clock(deadline_raw, time_unit);

    /* Attach to the shared memory and get pointer to the measurement ring buffer structure */
    if (tcc_measurement_buffer_init(buffer_size, measurement_name, &buffer) < 0) {
        pr_err("Can't init measurement buffer\n");
        return -TCC_E_ERROR;
    }

    /* Wait for the memory to be created */
    while (!tcc_measurement_buffer_check(measurement_name)) {
        sleep(0);
    }

    /* Read values while shared memory exists */
    while (tcc_measurement_buffer_check(measurement_name)) {
        /* Get the value from the array of measurement results. If the returned value is not zero, print the
         * value.*/
        if ((value = tcc_measurement_buffer_get(buffer)) != 0) {
            printf("%s: %lu CPU cycles", measurement_name, value);
            if (0 <= time_unit && time_unit < TCC_TU_UNKNOWN) {
                printf(" (%ld %s)",
                    tcc_measurement_convert_clock_to_time_units(value, time_unit),
                    tcc_measurement_get_string_from_time_unit(time_unit));
            }
            printf("\n");
            counter++;
        }

        /* If the deadline is defined and the value exceeded, print a message about it */
        if (deadline != 0 && value > deadline) {
            printf("Latency exceeding deadline: %lu CPU cycles", value);

            /* Print time unit only when it is defined in environment */
            if (0 <= time_unit && time_unit < TCC_TU_UNKNOWN) {
                printf(" (%ld %s)",
                    tcc_measurement_convert_clock_to_time_units(value, time_unit),
                    tcc_measurement_get_string_from_time_unit(time_unit));
            }
            printf("\n");
            deadline_counter++;
        }
    }

    if (deadline != 0) {
        printf("Deadline: %lu CPU cycles", deadline);

        /* Print time unit only when it is defined in environment */
        if (0 <= time_unit && time_unit < TCC_TU_UNKNOWN) {
            printf(" (%ld %s)",
                tcc_measurement_convert_clock_to_time_units(deadline, time_unit),
                tcc_measurement_get_string_from_time_unit(time_unit));
        }
        printf("\nNumber of exceeding deadlines: %u of %u\n", deadline_counter, counter);
    }
    printf("Count of read data: %u\n", counter);
    printf("Finishing monitoring\n");
    fflush(stdout);
    return TCC_E_SUCCESS;
}

TCC_ARGS_PARSE_STATUS parse_args(int argc, char** argv, __attribute__((unused)) settings_t* setting)
{
    static struct option long_options[] = {{"help", no_argument, NULL, 'h'}, {0, 0, 0, 0}};

    int option_index = 0;
    int opt = 0;
    while (opt != -1) {
        opt = getopt_long(argc, argv, "h", long_options, &option_index);
        switch (opt) {
        case 'h':
            return TCC_PRINT_HELP;
        case -1:
            break;
        default:
            return TCC_PARSE_ERROR;
        }
    }

    return TCC_PARSE_SUCCESS;
}

void print_usage()
{
    puts("Usage: [environment variables] tcc_measurement_monitoring_sample\n"
         "Options:\n"
         "    -h | --help            Show this help message and exit\n\n"
         "Environment variables setup:\n"
         "    TCC_MEASUREMENTS_BUFFERS\n"
         "        Measurement instances inside the profiled application to use to collect the measurement "
         "history.\n"
         "        Format: "
         "<measurement_name>:<buffer_size>[:<deadline>][,<measurement_name>:<buffer_size>[:<deadline>]]...\n"
         "        measurement_name   measurement name used by Instrumentation and Tracing Technology\n"
         "                           API (ITT API) in the profiled application for initializing the ITT\n"
         "                           handlers to collect performance data\n"
         "        buffer_size        number of measurements to store\n"
         "        deadline           maximum tolerable latency for each iteration in time units set by\n"
         "                           TCC_MEASUREMENTS_TIME_UNIT environment variable. It should be the same\n"
         "                           as the process that will record data\n"
         "    TCC_MEASUREMENTS_TIME_UNIT\n"
         "        Time unit that will be used to store the results.\n"
         "        Format: clk|ns|us\n"
         "        clk                for CPU clock cycles\n"
         "        ns                 for nanoseconds\n"
         "        us                 for microseconds\n"
         "    TCC_MEASUREMENTS_DUMP_FILE\n"
         "        File where measurements are logged after the program finishes.");
}
