/*******************************************************************************
Copyright Intel Corporation.
This software and the related documents are Intel copyrighted materials, and your use of them
is governed by the express license under which they were provided to you (License).
Unless the License provides otherwise, you may not use, modify, copy, publish, distribute, disclose
or transmit this software or the related documents without Intel's prior written permission.
This software and the related documents are provided as is, with no express or implied warranties,
other than those that are expressly stated in the License.

*******************************************************************************/

/**
 * @file pdatasource.c
 * @brief Implements logic of storage for produced data using cache allocation library
 * and pointer chasing workload
 *
 * This file implements data storage using cache allocation library and pointer chasing workload library,
 * This storage is used by data producer parts which are talker and compute and transmitter
 * application as a consumer part.
 * When data is being generated by producer it calls put_value_in_datasource() function,
 * after these actions consumer calls get_value_from_datasource() function.
 *
 * Latency statistic of accessing datasource can be requested by call of print_datasource_statistic()
 * function.
 * TCC Buffer API capabilities are used in order to allocate memory for data storage.
 *
 */

#include "pdatasource.h"

#include "macros.h"
#include "pcheck.h"
#include "pconfig.h"
#include "pointer_chasing.h"
#include "pointer_chasing_workload.h"

#include <pthread.h>
#include <sys/mman.h>
#include <tcc/cache.h>
#include <sys/sysinfo.h>
#include <tcc/measurement.h>

/* Workload related definitions */
#define WORKLOAD_ACCESSES (256)

/* Measurements collector related definitions */

#define COLLECTOR_LIBRARY_VAR_NAME "INTEL_LIBITTNOTIFY64"
#define COLLECTOR_LIBRARY_VAR_VALUE "libtcc_collector.so"
#define ITT_STRING_HANDLE_NAME "Workload"
#define ITT_STRING_DOMAIN_NAME "TCC"
#define TCC_MEASUREMENTS_BUFFERS_VAR_NAME "TCC_MEASUREMENTS_BUFFERS"
#define TCC_MEASUREMENTS_BUFFERS_VAR_VALUE ITT_STRING_HANDLE_NAME ":100000"
#define STATISTIC_DATA_FILENAME "tcc.stat"

static __itt_domain* gRtDomain = NULL;
static __itt_string_handle* gRtMeasurement = NULL;
static cache_line_node_t* gCacheLines = NULL;
static cache_line_node_t* gTargetNode = NULL;
static pthread_spinlock_t gCacheLinesGuard;

__attribute__((constructor)) static void cache_lines_guard_init(void)
{
    pthread_spin_init(&gCacheLinesGuard, 0);
}

__attribute__((destructor)) static void cache_lines_guard_fini(void)
{
    pthread_spin_destroy(&gCacheLinesGuard);
}

int prepare_datasource(uint64_t tcc_latency, int tcc_affinity)
{
    int res;
    char env_value[256] = {};

    /* Initialize the ITT task handle  to collect performance data for the sample workload */
    static const char measurement_name[] = ITT_STRING_HANDLE_NAME;
    gRtDomain = __itt_domain_create(ITT_STRING_DOMAIN_NAME);
    gRtMeasurement = __itt_string_handle_create(measurement_name);
    if (!gRtMeasurement) {
        tcc_cache_finish();
        pr_err("Cannot initialize measurement sub-system\n");
        return TCC_E_NOT_AVAILABLE;
    }

    if (getenv(COLLECTOR_LIBRARY_VAR_NAME) == NULL) {
        snprintf(env_value, sizeof(env_value), "%s", COLLECTOR_LIBRARY_VAR_VALUE);
        if (setenv(COLLECTOR_LIBRARY_VAR_NAME, env_value, 0)) {
            /* Warn but proceed */
            pr_err("Failed to set environment\n");
        }
    }

    if (getenv(TCC_MEASUREMENTS_BUFFERS_VAR_NAME) == NULL) {
        snprintf(env_value, sizeof(env_value), "%s", TCC_MEASUREMENTS_BUFFERS_VAR_VALUE);
        if (setenv(TCC_MEASUREMENTS_BUFFERS_VAR_NAME, env_value, 0)) {
            /* Warn but proceed */
            pr_err("Failed to set environment\n");
        }
    }

    if (mlockall(MCL_CURRENT | MCL_FUTURE) < 0) {
        /* Warn but proceed */
        pr_err("Cannot lock pages in memory\n");
    }

    pthread_spin_lock(&gCacheLinesGuard);
    if (pc_init(tcc_latency, tcc_affinity) < 0) {
        pthread_spin_unlock(&gCacheLinesGuard);
        res = tcc_cache_finish();
        if (res != TCC_E_SUCCESS) {
            print_error_description(res, "tcc_cache_finish()", __LINE__, __FILE__);
        }
        pr_err("Cannot init pointer chasing workload\n");
        return TCC_E_NOT_AVAILABLE;
    }

    gCacheLines = pc_get_workload_buffer(NULL);
    if (!gCacheLines) {
        pthread_spin_unlock(&gCacheLinesGuard);
        return TCC_E_MEMORY;
    }

    /* Find the target node for the 'put' operation */
    gTargetNode = pointer_chase_run_read_workload(gCacheLines, WORKLOAD_ACCESSES);
    pthread_spin_unlock(&gCacheLinesGuard);
    return TCC_E_SUCCESS;
}

void destroy_datasource(void)
{
    int iret;

    pthread_spin_lock(&gCacheLinesGuard);
    pc_fini();
    gCacheLines = NULL;
    gTargetNode = NULL;
    pthread_spin_unlock(&gCacheLinesGuard);
    iret = tcc_cache_finish();
    if (iret != TCC_E_SUCCESS) {
        print_error_description(iret, "tcc_cache_finish()", __LINE__, __FILE__);
    }
    munlockall();
}

void put_value_in_datasource(void* data)
{
    pthread_spin_lock(&gCacheLinesGuard);
    if (gTargetNode) {
        gTargetNode->data = data;
        pthread_spin_unlock(&gCacheLinesGuard);
    } else {
        pthread_spin_unlock(&gCacheLinesGuard);
        pr_err("No datasource target node to put a new value\n");
    }
}

#pragma GCC push_options
#pragma GCC optimize("O0")
void* get_value_from_datasource(void)
{
    void* value;
    cache_line_node_t* node;

    pthread_spin_lock(&gCacheLinesGuard);
    if (!gCacheLines) {
        pthread_spin_unlock(&gCacheLinesGuard);
        pr_err("No workload buffer to get a value\n");
        return NULL;
    }
    __itt_task_begin(gRtDomain, __itt_null, __itt_null, gRtMeasurement);
    node = pointer_chase_run_read_workload(gCacheLines, WORKLOAD_ACCESSES);
    __itt_task_end(gRtDomain);
    value = node->data;
    node->data = NULL;
    pthread_spin_unlock(&gCacheLinesGuard);
    return value;
}
#pragma GCC pop_options

void print_datasource_statistic(void)
{
    int tcc_sts = 0;
    struct tcc_measurement* tcc_measurement_ptr = NULL;
    FILE* dump_file = NULL;

    tcc_sts = tcc_measurement_get(gRtDomain, gRtMeasurement, &tcc_measurement_ptr);
    if (TCC_E_SUCCESS != tcc_sts) {
        perror("tcc_measurement_get(domain, measurement, &tcc_measurement_ptr) failed");
        goto print_tcc_statistic_exit;
    }

    dump_file = fopen(STATISTIC_DATA_FILENAME, "w");
    if (dump_file != NULL) {
        tcc_sts = tcc_measurement_print_history(tcc_measurement_ptr, dump_file, TCC_TU_NS);
        if (TCC_E_SUCCESS != tcc_sts) {
            perror("Unable to dump TCC statistic to file");
        }
        (void)fclose(dump_file);
    } else {
        perror("Unable to create file for TCC statistic");
    }

    tcc_measurement_get_avg(tcc_measurement_ptr);
    printf("\n*** Statistics for TCC workload ************************* \n");
    printf("    Minimum latency: %.0f CPU cycles (%ld us)\n",
        tcc_measurement_ptr->clk_min,
        tcc_measurement_convert_clock_to_timespec(tcc_measurement_ptr->clk_min).tv_nsec / 1000);
    printf("    Maximum latency: %.0f CPU cycles (%ld us)\n",
        tcc_measurement_ptr->clk_max,
        tcc_measurement_convert_clock_to_timespec(tcc_measurement_ptr->clk_max).tv_nsec / 1000);
    printf("    Average latency: %.0f CPU cycles (%ld us)\n",
        tcc_measurement_ptr->clk_result,
        tcc_measurement_convert_clock_to_timespec(tcc_measurement_ptr->clk_result).tv_nsec / 1000);
    printf("******************************************************** \n\n");

print_tcc_statistic_exit:
    return;
}
